'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var locale = require('locale');
var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var fusionCore = require('fusion-core');
var querystring = _interopDefault(require('querystring'));

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const loader = () => {
  const readDir = root => {
    try {
      return fs.readdirSync(root);
    } catch (e) {
      return [];
    }
  };

  const root = './translations';
  const locales = readDir(root).filter(p => p.match(/json$/)).map(p => p.replace(/\.json$/, ''));
  const data = locales.reduce((memo, locale$$1) => {
    const parsedLocale = new locale.Locale(locale$$1);
    memo[parsedLocale.normalized] = JSON.parse(fs.readFileSync(path.join(root, locale$$1 + '.json'), 'utf8'));
    return memo;
  }, {});
  const supportedLocales = new locale.Locales(locales);
  return {
    from: fusionCore.memoize(ctx => {
      const expectedLocales = new locale.Locales(ctx.headers['accept-language']);
      const locale$$1 = expectedLocales.best(supportedLocales);
      const translations = data[locale$$1.normalized];
      return {
        translations,
        locale: locale$$1
      };
    })
  };
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */
const I18nLoaderToken = fusionCore.createToken('I18nLoaderToken');
const plugin = true && fusionCore.createPlugin({
  deps: {
    loader: I18nLoaderToken.optional
  },
  provides: ({
    loader: loader$$1
  }) => {
    class I18n {
      constructor(ctx) {
        if (!loader$$1) {
          loader$$1 = loader();
        }

        const {
          translations,
          locale: locale$$1
        } = loader$$1.from(ctx);
        this.translations = translations;
        this.locale = locale$$1;
      }

      load() {} //mirror client API


      translate(key, interpolations = {}) {
        const template = this.translations[key];
        return template != null ? template.replace(/\${(.*?)}/g, (_, k) => interpolations[k]) : key;
      }

    }

    const plugin = {
      from: fusionCore.memoize(ctx => new I18n(ctx))
    };
    return plugin;
  },
  middleware: (_, plugin) => {
    // TODO(#4) refactor: this currently depends on babel plugins in framework's webpack config.
    // Ideally these babel plugins should be part of this package, not hard-coded in framework core
    const chunkTranslationMap = require('../chunk-translation-map');

    return async (ctx, next) => {
      if (ctx.element) {
        await next();
        const i18n = plugin.from(ctx); // get the webpack chunks that are used and serialize their translations

        const chunks = [...ctx.syncChunks, ...ctx.preloadChunks];
        const translations = {};
        chunks.forEach(id => {
          const keys = Array.from(chunkTranslationMap.translationsForChunk(id));
          keys.forEach(key => {
            translations[key] = i18n.translations[key];
          });
        });
        const serialized = JSON.stringify({
          chunks,
          translations
        });
        const script = fusionCore.html`<script type='application/json' id="__TRANSLATIONS__">${serialized}</script>`; // consumed by ./browser
        // $FlowFixMe

        ctx.template.body.push(script);
      } else if (ctx.path === '/_translations') {
        const i18n = plugin.from(ctx);
        const ids = querystring.parse(ctx.querystring).ids || '';
        const chunks = ids.split(',').map(id => parseInt(id, 10));
        const translations = {};
        chunks.forEach(id => {
          const keys = [...chunkTranslationMap.translationsForChunk(id)];
          keys.forEach(key => {
            translations[key] = i18n.translations[key];
          });
        });
        ctx.body = translations;
        return next();
      } else {
        return next();
      }
    };
  }
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
const HydrationStateToken = fusionCore.createToken('HydrationStateToken');

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const I18nToken = fusionCore.createToken('I18nToken');
const plugin$3 = plugin;

exports.default = plugin$3;
exports.I18nToken = I18nToken;
exports.I18nLoaderToken = I18nLoaderToken;
exports.HydrationStateToken = HydrationStateToken;
exports.createI18nLoader = loader;
//# sourceMappingURL=index.js.map
