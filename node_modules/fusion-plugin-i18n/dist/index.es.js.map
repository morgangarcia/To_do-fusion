{"version":3,"file":"index.es.js","sources":["../src/loader.js","../src/node.js","../src/browser.js","../src/index.js"],"sourcesContent":["/** Copyright (c) 2018 Uber Technologies, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {Locale, Locales} from 'locale';\nimport fs from 'fs';\nimport path from 'path';\n\nimport {memoize} from 'fusion-core';\nimport type {Context} from 'fusion-core';\n\nexport type I18nLoaderType = {\n  from: (ctx: Context) => {locale: string, translations: Object},\n};\n\nconst loader = __NODE__\n  ? () => {\n      const readDir = root => {\n        try {\n          return fs.readdirSync(root);\n        } catch (e) {\n          return [];\n        }\n      };\n      const root = './translations';\n      const locales = readDir(root)\n        .filter(p => p.match(/json$/))\n        .map(p => p.replace(/\\.json$/, ''));\n      const data = locales.reduce((memo, locale) => {\n        const parsedLocale = new Locale(locale);\n        memo[parsedLocale.normalized] = JSON.parse(\n          fs.readFileSync(path.join(root, locale + '.json'), 'utf8')\n        );\n        return memo;\n      }, {});\n      const supportedLocales = new Locales(locales);\n\n      return {\n        from: memoize(ctx => {\n          const expectedLocales = new Locales(ctx.headers['accept-language']);\n          const locale: Locale = expectedLocales.best(supportedLocales);\n          const translations: Object = data[locale.normalized];\n          return {translations, locale};\n        }),\n      };\n    }\n  : null;\n\nexport default ((loader: any): () => I18nLoaderType);\n","/** Copyright (c) 2018 Uber Technologies, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/* eslint-env node */\nimport querystring from 'querystring';\n\nimport {createToken, createPlugin, memoize, html} from 'fusion-core';\nimport type {FusionPlugin, Token} from 'fusion-core';\n\nimport createLoader from './loader.js';\nimport type {I18nLoaderType} from './loader.js';\n\nexport const I18nLoaderToken: Token<I18nLoaderType> = createToken(\n  'I18nLoaderToken'\n);\nconst plugin =\n  __NODE__ &&\n  createPlugin({\n    deps: {\n      loader: I18nLoaderToken.optional,\n    },\n    provides: ({loader}) => {\n      class I18n {\n        translations: Object;\n        locale: string;\n\n        constructor(ctx) {\n          if (!loader) {\n            loader = createLoader();\n          }\n          const {translations, locale} = loader.from(ctx);\n          this.translations = translations;\n          this.locale = locale;\n        }\n        load() {} //mirror client API\n        translate(key, interpolations = {}) {\n          const template = this.translations[key];\n          return template != null\n            ? template.replace(/\\${(.*?)}/g, (_, k) => interpolations[k])\n            : key;\n        }\n      }\n      const plugin = {from: memoize(ctx => new I18n(ctx))};\n      return plugin;\n    },\n    middleware: (_, plugin) => {\n      // TODO(#4) refactor: this currently depends on babel plugins in framework's webpack config.\n      // Ideally these babel plugins should be part of this package, not hard-coded in framework core\n      const chunkTranslationMap = require('../chunk-translation-map');\n      return async (ctx, next) => {\n        if (ctx.element) {\n          await next();\n          const i18n = plugin.from(ctx);\n\n          // get the webpack chunks that are used and serialize their translations\n          const chunks = [...ctx.syncChunks, ...ctx.preloadChunks];\n          const translations = {};\n          chunks.forEach(id => {\n            const keys = Array.from(\n              chunkTranslationMap.translationsForChunk(id)\n            );\n            keys.forEach(key => {\n              translations[key] = i18n.translations[key];\n            });\n          });\n          const serialized = JSON.stringify({chunks, translations});\n          const script = html`<script type='application/json' id=\"__TRANSLATIONS__\">${serialized}</script>`; // consumed by ./browser\n          // $FlowFixMe\n          ctx.template.body.push(script);\n        } else if (ctx.path === '/_translations') {\n          const i18n = plugin.from(ctx);\n          const ids = querystring.parse(ctx.querystring).ids || '';\n          const chunks = ids.split(',').map(id => parseInt(id, 10));\n          const translations = {};\n          chunks.forEach(id => {\n            const keys = [...chunkTranslationMap.translationsForChunk(id)];\n            keys.forEach(key => {\n              translations[key] = i18n.translations[key];\n            });\n          });\n          ctx.body = translations;\n          return next();\n        } else {\n          return next();\n        }\n      };\n    },\n  });\n\nexport default ((plugin: any): FusionPlugin<*, *>);\n","/** Copyright (c) 2018 Uber Technologies, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/* eslint-env browser */\nimport {FetchToken} from 'fusion-tokens';\nimport {createPlugin, unescape, createToken} from 'fusion-core';\nimport type {FusionPlugin, Token} from 'fusion-core';\n\nimport type {I18nDepsType, I18nServiceType} from './flow.js';\n\nfunction loadTranslations() {\n  const element = document.getElementById('__TRANSLATIONS__');\n  if (!element) {\n    throw new Error(\n      '[fusion-plugin-i18n] - Could not find a __TRANSLATIONS__ element'\n    );\n  }\n  try {\n    return JSON.parse(unescape(element.textContent));\n  } catch (e) {\n    throw new Error(\n      '[fusion-plugin-i18n] - Error parsing __TRANSLATIONS__ element content'\n    );\n  }\n}\n\ntype HydrationStateType = {\n  chunks: Array<number>,\n  translations: Object,\n};\nexport const HydrationStateToken: Token<HydrationStateType> = createToken(\n  'HydrationStateToken'\n);\nconst plugin =\n  __BROWSER__ &&\n  createPlugin({\n    deps: {\n      fetch: FetchToken.optional,\n      hydrationState: HydrationStateToken.optional,\n    },\n    provides: ({fetch = window.fetch, hydrationState} = {}) => {\n      class I18n {\n        loadedChunks: any;\n        translationMap: any;\n\n        constructor() {\n          const {chunks, translations} = hydrationState || loadTranslations();\n          this.loadedChunks = chunks || [];\n          this.translationMap = translations || {};\n        }\n        load(chunkIds) {\n          const unloaded = chunkIds.filter(id => {\n            return this.loadedChunks.indexOf(id) < 0;\n          });\n          if (unloaded.length > 0) {\n            const ids = unloaded.join(',');\n            // TODO(#3) don't append prefix if injected fetch also injects prefix\n            return fetch(`/_translations?ids=${ids}`, {method: 'POST'})\n              .then(r => r.json())\n              .then(data => {\n                for (const key in data) this.translationMap[key] = data[key];\n                unloaded.forEach(id => {\n                  this.loadedChunks[id] = true;\n                });\n              });\n          }\n        }\n        translate(key, interpolations = {}) {\n          const template = this.translationMap[key];\n          return template\n            ? template.replace(/\\${(.*?)}/g, (_, k) => interpolations[k])\n            : key;\n        }\n      }\n      const i18n = new I18n();\n      return {from: () => i18n};\n    },\n  });\n\nexport default ((plugin: any): FusionPlugin<I18nDepsType, I18nServiceType>);\n","/** Copyright (c) 2018 Uber Technologies, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {createToken} from 'fusion-core';\nimport type {FusionPlugin, Token} from 'fusion-core';\n\nimport serverPlugin, {I18nLoaderToken} from './node';\nimport clientPlugin, {HydrationStateToken} from './browser';\nimport createI18nLoader from './loader';\nimport type {I18nDepsType, I18nServiceType} from './flow.js';\n\nexport type {I18nServiceType} from './flow.js';\nconst I18nToken: Token<I18nServiceType> = createToken('I18nToken');\n\nconst plugin: FusionPlugin<I18nDepsType, I18nServiceType> = __NODE__\n  ? serverPlugin\n  : clientPlugin;\n\nexport default plugin;\nexport {I18nToken, I18nLoaderToken, HydrationStateToken, createI18nLoader};\n"],"names":["loader","readDir","root","fs","readdirSync","e","locales","filter","p","match","map","replace","data","reduce","memo","locale","parsedLocale","Locale","normalized","JSON","parse","readFileSync","path","join","supportedLocales","Locales","memoize","ctx","expectedLocales","headers","best","translations","I18nLoaderToken","createToken","plugin","createPlugin","optional","I18n","createLoader","from","key","interpolations","template","_","k","chunkTranslationMap","require","next","element","i18n","chunks","syncChunks","preloadChunks","forEach","id","keys","Array","translationsForChunk","serialized","stringify","script","html","body","push","ids","querystring","split","parseInt","HydrationStateToken","I18nToken","serverPlugin"],"mappings":"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"}