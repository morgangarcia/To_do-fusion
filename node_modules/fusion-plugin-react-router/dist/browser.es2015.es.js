import React from 'react';
import PropTypes from 'prop-types';
import { createPath, parsePath } from 'history';
import { Router, Route, BrowserRouter, HashRouter, Link, MemoryRouter, NavLink, Prompt, Switch, matchPath, withRouter } from 'react-router-dom';
import createHistory from 'history/createBrowserHistory';
import { UniversalEventsToken } from 'fusion-plugin-universal-events';
import { createPlugin, unescape } from 'fusion-core';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class Status extends React.Component {
  constructor(props, context) {
    super(props, context);
    const {
      router: {
        staticContext
      }
    } = context;

    if (staticContext && staticContext.setCode) {
      staticContext.setCode(parseInt(this.props.code, 10));
    }
  }

  render() {
    const children = this.props && this.props.children;
    return Array.isArray(children) ? children[0] : children;
  }

}
Status.contextTypes = {
  router: PropTypes.shape({
    staticContext: PropTypes.object
  })
};
const NotFound = props => React.createElement(Status, {
  code: 404
}, props.children);

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class Redirect extends React.Component {
  constructor(props, context) {
    super(props, context);
    if (this.isStatic(context)) this.perform();
  }

  componentDidMount() {
    if (!this.isStatic()) this.perform();
  }

  isStatic(context = this.context) {
    return context.router && context.router.staticContext;
  }

  perform() {
    const {
      history,
      staticContext
    } = this.context.router;
    const {
      push,
      to,
      code
    } = this.props;

    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  }

  render() {
    return null;
  }

} // $FlowFixMe

Redirect.defaultProps = {
  push: false,
  code: 307
};
Redirect.contextTypes = {
  router: PropTypes.shape({
    history: PropTypes.shape({
      push: PropTypes.func.isRequired,
      replace: PropTypes.func.isRequired
    }).isRequired,
    staticContext: PropTypes.object
  }).isRequired
};

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const addLeadingSlash = path => path.charAt(0) === '/' ? path : '/' + path;
/**
 * @param {string|object} location
 * @param {string} prefix
 * @returns {object}
 */


const addRoutePrefix = (location, prefix) => {
  if (!prefix) return location;

  if (typeof location === 'string') {
    return `${prefix}${addLeadingSlash(location)}`;
  } else {
    return _objectSpread({}, location, {
      pathname: `${prefix}${addLeadingSlash(location.pathname)}`
    });
  }
};
/**
 * @param {string|object} location
 * @param {string} prefix
 * @returns {object}
 */


const removeRoutePrefix = (location, prefix) => {
  if (!prefix) return location;
  const pathname = typeof location === 'string' ? location : location.pathname;
  const hasPrefix = (pathname + '/').indexOf(prefix + '/') === 0;
  const unprefixedPathname = pathname.slice(prefix.length);
  const relativePathname = hasPrefix ? unprefixedPathname : pathname;

  if (typeof location === 'string') {
    return relativePathname;
  } else {
    return _objectSpread({}, location, {
      pathname: relativePathname
    });
  }
};
/**
 * @param {string} path
 * @param {string} prefix
 * @returns {object}
 */


const createLocation = (path, prefix) => {
  const unprefixedPath = removeRoutePrefix(path, prefix);
  return parsePath(unprefixedPath);
};
/**
 * @param {string|object} location
 * @param {string} prefix
 * @returns {string}
 */


const createPrefixedURL = (location, prefix) => {
  if (typeof location === 'string') {
    return addRoutePrefix(location, prefix);
  } else {
    return createPath(addRoutePrefix(location, prefix));
  }
};
/**
 * @param {string|object} location
 * @param {string} prefix
 * @returns {string}
 */


const createURL = (location, prefix) => {
  if (typeof location === 'string') {
    return removeRoutePrefix(location, prefix);
  } else {
    return createPath(removeRoutePrefix(location, prefix));
  }
};

const staticHandler = methodName => () => {
  throw new Error(`You cannot ${methodName} with server side <Router>`);
};

const noop = () => {};
/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */


class ServerRouter extends React.Component {
  getChildContext() {
    return {
      router: {
        staticContext: this.props.context || {}
      },
      onRoute: routeData => this.props.onRoute(routeData)
    };
  }
  /**
   * @param {string|object} location
   * @returns {string}
   */


  createHref(location) {
    return createPrefixedURL(location, this.props.basename);
  }
  /**
   * @param {string} path
   */


  handlePush(path) {
    const {
      basename,
      context
    } = this.props;
    context.action = 'PUSH';
    context.location = createLocation(path, basename);
    context.url = createURL(path, basename);
  }
  /**
   * @param {string} path
   */


  handleReplace(path) {
    const {
      basename,
      context
    } = this.props;
    context.action = 'REPLACE';
    context.location = createLocation(path, basename);
    context.url = createURL(path, basename);
  }

  handleListen() {
    return noop;
  }

  render() {
    /* eslint-disable no-unused-vars */
    const _this$props = this.props,
          {
      context,
      location
    } = _this$props,
          props = _objectWithoutProperties(_this$props, ["context", "location"]);
    /* eslint-enable no-unused-vars */


    const history = {
      createHref: this.createHref.bind(this),
      action: 'POP',
      location: createLocation(location, this.props.basename),
      push: this.handlePush.bind(this),
      replace: this.handleReplace.bind(this),
      go: staticHandler('go'),
      back: staticHandler('back'),
      forward: staticHandler('forward'),
      listen: this.handleListen
    };
    return React.createElement(Router, _extends({}, props, {
      history: history
    }));
  }

} // $FlowFixMe

ServerRouter.defaultProps = {
  basename: '',
  location: '/',
  context: {},
  onRoute: () => {}
};
ServerRouter.childContextTypes = {
  router: () => {},
  onRoute: () => {}
};

function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }

function _objectWithoutProperties$1(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const isEmptyChildren = children => React.Children.count(children) === 0;

function Route$1(props, context) {
  const {
    trackingId,
    component,
    render,
    children
  } = props,
        remainingProps = _objectWithoutProperties$1(props, ["trackingId", "component", "render", "children"]);

  return React.createElement(Route, _extends$1({}, remainingProps, {
    // eslint-disable-next-line react/no-children-prop
    children: routeProps => {
      const {
        match
      } = routeProps;

      if (match && match.isExact) {
        context.onRoute({
          page: match.path,
          title: trackingId || match.path
        });
      }

      if (component) return match ? React.createElement(component, routeProps) : null;
      if (render) return match ? render(routeProps) : null;
      if (typeof children === 'function') return children(routeProps);
      if (children && !isEmptyChildren(children)) return React.Children.only(children);
      return null;
    }
  }));
}

Route$1.contextTypes = {
  onRoute: PropTypes.func.isRequired
};
Route$1.displayName = 'FusionRoute';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class BrowserRouter$1 extends React.Component {
  constructor(props = {}, context) {
    super(props, context);
    this.history = createHistory(this.props);
    this.lastTitle = null;
  }

  getChildContext() {
    const {
      __IS_PREPARE__
    } = this.context;
    return {
      onRoute: routeData => {
        if (routeData.title !== this.lastTitle && !__IS_PREPARE__) {
          this.lastTitle = routeData.title;
          this.props.onRoute(routeData);
        }
      }
    };
  }

  render() {
    return React.createElement(Router, {
      history: this.history
    }, this.props.children);
  }

}

BrowserRouter$1.propTypes = {
  basename: PropTypes.string,
  forceRefresh: PropTypes.bool,
  getUserConfirmation: PropTypes.func,
  keyLength: PropTypes.number,
  children: PropTypes.node,
  onRoute: PropTypes.func
};
BrowserRouter$1.contextTypes = {
  __IS_PREPARE__: PropTypes.bool
};
BrowserRouter$1.childContextTypes = {
  onRoute: PropTypes.func.isRequired
}; // $FlowFixMe

BrowserRouter$1.defaultProps = {
  onRoute: () => {}
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const Router$1 = BrowserRouter$1;
var plugin = createPlugin({
  deps: {
    emitter: UniversalEventsToken.optional
  },
  middleware: ({
    emitter
  }) => (ctx, next) => new Promise(function ($return, $error) {
    const prefix = ctx.prefix || '';

    if (!ctx.element) {
      return $return(next());
    }

    {
      // TODO(#3): We should consider adding render/downstream/upstream timings for the browser
      let pageData = {};
      const element = document.getElementById('__ROUTER_DATA__');

      if (element) {
        pageData = JSON.parse(unescape(element.textContent));
      }

      emitter && emitter.map(payload => {
        if (payload && typeof payload === 'object') {
          payload.__url__ = pageData.title;
        }

        return payload;
      });
      ctx.element = React.createElement(Router$1, {
        basename: ctx.prefix,
        onRoute: payload => {
          pageData = payload;
          emitter && emitter.emit('pageview:browser', payload);
        }
      }, ctx.element);
      return $return(next());
    }

    return $return();
  })
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const BrowserRouter$2 = BrowserRouter;
const HashRouter$1 = HashRouter;
const Link$1 = Link;
const matchPath$1 = matchPath;
const MemoryRouter$1 = MemoryRouter;
const NavLink$1 = NavLink;
const Prompt$1 = Prompt;
const Route$2 = Route$1;
const Router$2 = BrowserRouter$1;
const Switch$1 = Switch;
const withRouter$1 = withRouter;
const NotFound$1 = NotFound;
const Redirect$1 = Redirect;
const Status$1 = Status;

export default plugin;
export { BrowserRouter$2 as BrowserRouter, HashRouter$1 as HashRouter, Link$1 as Link, matchPath$1 as matchPath, MemoryRouter$1 as MemoryRouter, NavLink$1 as NavLink, NotFound$1 as NotFound, Prompt$1 as Prompt, Redirect$1 as Redirect, Route$2 as Route, Router$2 as Router, Status$1 as Status, Switch$1 as Switch, withRouter$1 as withRouter };
//# sourceMappingURL=browser.es2015.es.js.map
