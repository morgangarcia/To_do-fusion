'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(require('react'));
var PropTypes = _interopDefault(require('prop-types'));
var history = require('history');
var browser = require('react-router-dom');
var createHistory = _interopDefault(require('history/createBrowserHistory'));
var fusionPluginUniversalEvents = require('fusion-plugin-universal-events');
var fusionCore = require('fusion-core');

function _inheritsLoose(subClass, superClass) { subClass.prototype.__proto__ = superClass && superClass.prototype; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Status =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Status, _React$Component);

  function Status(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var staticContext = context.router.staticContext;

    if (staticContext && staticContext.setCode) {
      staticContext.setCode(parseInt(_this.props.code, 10));
    }

    return _this;
  }

  var _proto = Status.prototype;

  _proto.render = function render() {
    var children = this.props && this.props.children;
    return Array.isArray(children) ? children[0] : children;
  };

  return Status;
}(React.Component);
Status.contextTypes = {
  router: PropTypes.shape({
    staticContext: PropTypes.object
  })
};
var NotFound = function NotFound(props) {
  return React.createElement(Status, {
    code: 404
  }, props.children);
};

function _inheritsLoose$1(subClass, superClass) { subClass.prototype.__proto__ = superClass && superClass.prototype; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Redirect =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose$1(Redirect, _React$Component);

  function Redirect(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    if (_this.isStatic(context)) _this.perform();
    return _this;
  }

  var _proto = Redirect.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (!this.isStatic()) this.perform();
  };

  _proto.isStatic = function isStatic(context) {
    if (context === void 0) {
      context = this.context;
    }

    return context.router && context.router.staticContext;
  };

  _proto.perform = function perform() {
    var _this$context$router = this.context.router,
        history$$1 = _this$context$router.history,
        staticContext = _this$context$router.staticContext;
    var _this$props = this.props,
        push = _this$props.push,
        to = _this$props.to,
        code = _this$props.code;

    if (push) {
      history$$1.push(to);
    } else {
      history$$1.replace(to);
    }
  };

  _proto.render = function render() {
    return null;
  };

  return Redirect;
}(React.Component); // $FlowFixMe

Redirect.defaultProps = {
  push: false,
  code: 307
};
Redirect.contextTypes = {
  router: PropTypes.shape({
    history: PropTypes.shape({
      push: PropTypes.func.isRequired,
      replace: PropTypes.func.isRequired
    }).isRequired,
    staticContext: PropTypes.object
  }).isRequired
};

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _inheritsLoose$2(subClass, superClass) { subClass.prototype.__proto__ = superClass && superClass.prototype; subClass.__proto__ = superClass; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};
/**
 * @param {string|object} location
 * @param {string} prefix
 * @returns {object}
 */


var addRoutePrefix = function addRoutePrefix(location, prefix) {
  if (!prefix) return location;

  if (typeof location === 'string') {
    return "" + prefix + addLeadingSlash(location);
  } else {
    return _objectSpread({}, location, {
      pathname: "" + prefix + addLeadingSlash(location.pathname)
    });
  }
};
/**
 * @param {string|object} location
 * @param {string} prefix
 * @returns {object}
 */


var removeRoutePrefix = function removeRoutePrefix(location, prefix) {
  if (!prefix) return location;
  var pathname = typeof location === 'string' ? location : location.pathname;
  var hasPrefix = (pathname + '/').indexOf(prefix + '/') === 0;
  var unprefixedPathname = pathname.slice(prefix.length);
  var relativePathname = hasPrefix ? unprefixedPathname : pathname;

  if (typeof location === 'string') {
    return relativePathname;
  } else {
    return _objectSpread({}, location, {
      pathname: relativePathname
    });
  }
};
/**
 * @param {string} path
 * @param {string} prefix
 * @returns {object}
 */


var createLocation = function createLocation(path, prefix) {
  var unprefixedPath = removeRoutePrefix(path, prefix);
  return history.parsePath(unprefixedPath);
};
/**
 * @param {string|object} location
 * @param {string} prefix
 * @returns {string}
 */


var createPrefixedURL = function createPrefixedURL(location, prefix) {
  if (typeof location === 'string') {
    return addRoutePrefix(location, prefix);
  } else {
    return history.createPath(addRoutePrefix(location, prefix));
  }
};
/**
 * @param {string|object} location
 * @param {string} prefix
 * @returns {string}
 */


var createURL = function createURL(location, prefix) {
  if (typeof location === 'string') {
    return removeRoutePrefix(location, prefix);
  } else {
    return history.createPath(removeRoutePrefix(location, prefix));
  }
};

var staticHandler = function staticHandler(methodName) {
  return function () {
    throw new Error("You cannot " + methodName + " with server side <Router>");
  };
};

var noop = function noop() {};
/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */


var ServerRouter =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose$2(ServerRouter, _React$Component);

  function ServerRouter() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = ServerRouter.prototype;

  _proto.getChildContext = function getChildContext() {
    var _this = this;

    return {
      router: {
        staticContext: this.props.context || {}
      },
      onRoute: function onRoute(routeData) {
        return _this.props.onRoute(routeData);
      }
    };
  };
  /**
   * @param {string|object} location
   * @returns {string}
   */


  _proto.createHref = function createHref(location) {
    return createPrefixedURL(location, this.props.basename);
  };
  /**
   * @param {string} path
   */


  _proto.handlePush = function handlePush(path) {
    var _this$props = this.props,
        basename = _this$props.basename,
        context = _this$props.context;
    context.action = 'PUSH';
    context.location = createLocation(path, basename);
    context.url = createURL(path, basename);
  };
  /**
   * @param {string} path
   */


  _proto.handleReplace = function handleReplace(path) {
    var _this$props2 = this.props,
        basename = _this$props2.basename,
        context = _this$props2.context;
    context.action = 'REPLACE';
    context.location = createLocation(path, basename);
    context.url = createURL(path, basename);
  };

  _proto.handleListen = function handleListen() {
    return noop;
  };

  _proto.render = function render() {
    /* eslint-disable no-unused-vars */
    var _this$props3 = this.props,
        context = _this$props3.context,
        location = _this$props3.location,
        props = _objectWithoutProperties(_this$props3, ["context", "location"]);
    /* eslint-enable no-unused-vars */


    var history$$1 = {
      createHref: this.createHref.bind(this),
      action: 'POP',
      location: createLocation(location, this.props.basename),
      push: this.handlePush.bind(this),
      replace: this.handleReplace.bind(this),
      go: staticHandler('go'),
      back: staticHandler('back'),
      forward: staticHandler('forward'),
      listen: this.handleListen
    };
    return React.createElement(browser.Router, _extends({}, props, {
      history: history$$1
    }));
  };

  return ServerRouter;
}(React.Component); // $FlowFixMe

ServerRouter.defaultProps = {
  basename: '',
  location: '/',
  context: {},
  onRoute: function onRoute() {}
};
ServerRouter.childContextTypes = {
  router: function router() {},
  onRoute: function onRoute() {}
};

function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }

function _objectWithoutProperties$1(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var isEmptyChildren = function isEmptyChildren(children) {
  return React.Children.count(children) === 0;
};

function Route(props, context) {
  var trackingId = props.trackingId,
      component = props.component,
      render = props.render,
      _children = props.children,
      remainingProps = _objectWithoutProperties$1(props, ["trackingId", "component", "render", "children"]);

  return React.createElement(browser.Route, _extends$1({}, remainingProps, {
    // eslint-disable-next-line react/no-children-prop
    children: function children(routeProps) {
      var match = routeProps.match;

      if (match && match.isExact) {
        context.onRoute({
          page: match.path,
          title: trackingId || match.path
        });
      }

      if (component) return match ? React.createElement(component, routeProps) : null;
      if (render) return match ? render(routeProps) : null;
      if (typeof _children === 'function') return _children(routeProps);
      if (_children && !isEmptyChildren(_children)) return React.Children.only(_children);
      return null;
    }
  }));
}

Route.contextTypes = {
  onRoute: PropTypes.func.isRequired
};
Route.displayName = 'FusionRoute';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function _inheritsLoose$3(subClass, superClass) { subClass.prototype.__proto__ = superClass && superClass.prototype; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var BrowserRouter =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose$3(BrowserRouter, _React$Component);

  function BrowserRouter(props, context) {
    var _this;

    if (props === void 0) {
      props = {};
    }

    _this = _React$Component.call(this, props, context) || this;
    _this.history = createHistory(_this.props);
    _this.lastTitle = null;
    return _this;
  }

  var _proto = BrowserRouter.prototype;

  _proto.getChildContext = function getChildContext() {
    var _this2 = this;

    var __IS_PREPARE__ = this.context.__IS_PREPARE__;
    return {
      onRoute: function onRoute(routeData) {
        if (routeData.title !== _this2.lastTitle && !__IS_PREPARE__) {
          _this2.lastTitle = routeData.title;

          _this2.props.onRoute(routeData);
        }
      }
    };
  };

  _proto.render = function render() {
    return React.createElement(browser.Router, {
      history: this.history
    }, this.props.children);
  };

  return BrowserRouter;
}(React.Component);

BrowserRouter.propTypes = {
  basename: PropTypes.string,
  forceRefresh: PropTypes.bool,
  getUserConfirmation: PropTypes.func,
  keyLength: PropTypes.number,
  children: PropTypes.node,
  onRoute: PropTypes.func
};
BrowserRouter.contextTypes = {
  __IS_PREPARE__: PropTypes.bool
};
BrowserRouter.childContextTypes = {
  onRoute: PropTypes.func.isRequired
}; // $FlowFixMe

BrowserRouter.defaultProps = {
  onRoute: function onRoute() {}
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var _templateObject = /*#__PURE__*/ _taggedTemplateLiteralLoose(["<script id=\"__ROUTER_DATA__\" type=\"application/json\">", "</script>"], ["<script id=\"__ROUTER_DATA__\" type=\"application/json\">", "</script>"]);

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Router$$1 = BrowserRouter;
var plugin = fusionCore.createPlugin({
  deps: {
    emitter: fusionPluginUniversalEvents.UniversalEventsToken.optional
  },
  middleware: function middleware(_ref) {
    var emitter = _ref.emitter;
    return function (ctx, next) {
      return new Promise(function ($return, $error) {
        var prefix = ctx.prefix || '';

        if (!ctx.element) {
          return $return(next());
        }

        {
          // TODO(#3): We should consider adding render/downstream/upstream timings for the browser
          var _pageData = {};
          var element = document.getElementById('__ROUTER_DATA__');

          if (element) {
            _pageData = JSON.parse(fusionCore.unescape(element.textContent));
          }

          emitter && emitter.map(function (payload) {
            if (payload && _typeof(payload) === 'object') {
              payload.__url__ = _pageData.title;
            }

            return payload;
          });
          ctx.element = React.createElement(Router$$1, {
            basename: ctx.prefix,
            onRoute: function onRoute(payload) {
              _pageData = payload;
              emitter && emitter.emit('pageview:browser', payload);
            }
          }, ctx.element);
          return $return(next());
        }

        return $return();
      });
    };
  }
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var BrowserRouter$1 = browser.BrowserRouter;
var HashRouter = browser.HashRouter;
var Link = browser.Link;
var matchPath = browser.matchPath;
var MemoryRouter = browser.MemoryRouter;
var NavLink = browser.NavLink;
var Prompt = browser.Prompt;
var Route$1 = Route;
var Router$1 = BrowserRouter;
var Switch = browser.Switch;
var withRouter = browser.withRouter;
var NotFound$1 = NotFound;
var Redirect$1 = Redirect;
var Status$1 = Status;

exports.default = plugin;
exports.BrowserRouter = BrowserRouter$1;
exports.HashRouter = HashRouter;
exports.Link = Link;
exports.matchPath = matchPath;
exports.MemoryRouter = MemoryRouter;
exports.NavLink = NavLink;
exports.NotFound = NotFound$1;
exports.Prompt = Prompt;
exports.Redirect = Redirect$1;
exports.Route = Route$1;
exports.Router = Router$1;
exports.Status = Status$1;
exports.Switch = Switch;
exports.withRouter = withRouter;
//# sourceMappingURL=browser.es5.js.map
