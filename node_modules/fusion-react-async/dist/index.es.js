import React__default, { Component } from 'react';
import PropTypes from 'prop-types';
import { isFragment, isContextConsumer, isContextProvider } from 'react-is';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const REACT_PREPARE = '@__REACT_PREPARE__@';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const prepared = (prepare, opts = {}) => OriginalComponent => {
  opts = Object.assign({
    boundary: false,
    defer: false,
    componentDidMount: true,
    componentWillReceiveProps: false,
    componentDidUpdate: false,
    contextTypes: {},
    forceUpdate: false
  }, opts);
  const prep = {
    prepare: (...args) => Promise.resolve(prepare(...args)),
    defer: opts.defer
  };

  class PreparedComponent extends Component {
    constructor(props, context) {
      super(props, context);
      this[REACT_PREPARE] = prep;
    }

    componentDidMount() {
      if (opts.componentDidMount) {
        Promise.resolve(prepare(this.props, this.context)).then(() => {
          if (opts.forceUpdate) {
            this.forceUpdate(); // TODO(#10) document
          }
        });
      }
    }

    componentWillReceiveProps(nextProps, nextContext) {
      if (opts.componentWillReceiveProps) {
        prepare(nextProps, nextContext);
      }
    }

    componentDidUpdate() {
      if (opts.componentDidUpdate) {
        prepare(this.props, this.context);
      }
    }

    render() {
      return React__default.createElement(OriginalComponent, this.props);
    }

  }

  const displayName = OriginalComponent.displayName || OriginalComponent.name || '';
  PreparedComponent.contextTypes = opts.contextTypes;
  PreparedComponent.displayName = `PreparedComponent(${displayName})`;
  return PreparedComponent;
};

function isPrepared(CustomComponent) {
  return CustomComponent[REACT_PREPARE] && typeof CustomComponent[REACT_PREPARE].prepare === 'function';
}

function getPrepare(CustomComponent) {
  return CustomComponent[REACT_PREPARE] || {};
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const storeShape = PropTypes.shape({
  dispatch: PropTypes.func.isRequired
});

const dispatched = (prepareUsingDispatch, opts = {}) => OriginalComponent => {
  const prepare = (props, context) => {
    return prepareUsingDispatch(props, context.store.dispatch);
  };

  const contextTypes = Object.assign({}, opts && opts.contextTypes ? opts.contextTypes : {}, {
    store: storeShape
  });
  const preparedOpts = Object.assign({}, opts, {
    contextTypes
  });
  return prepared(prepare, preparedOpts)(OriginalComponent);
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function isReactCompositeComponent(type) {
  if (typeof type !== 'function') {
    return false;
  }

  if (typeof type.prototype !== 'object') {
    return false;
  }

  if (typeof type.prototype.render !== 'function') {
    return false;
  }

  return true;
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function renderCompositeElementInstance(instance) {
  const childContext = Object.assign({}, instance.context, instance.getChildContext ? instance.getChildContext() : {});

  if (instance.componentWillMount) {
    instance.componentWillMount();
  }

  const children = instance.render();
  return [children, childContext];
}

function prepareComponentInstance(instance) {
  if (!isPrepared(instance)) {
    return Promise.resolve({});
  }

  const prepareConfig = getPrepare(instance); // If the component is deferred, skip the prepare step

  if (prepareConfig.defer) {
    return Promise.resolve(prepareConfig);
  }

  return prepareConfig.prepare(instance.props, instance.context).then(() => {
    return prepareConfig;
  });
}

function prepareElement(element, context) {
  if (element === null || typeof element !== 'object') {
    return Promise.resolve([null, context]);
  }

  const {
    type,
    props
  } = element;

  if (typeof type === 'string' || isFragment(element) || isContextConsumer(element) || isContextProvider(element)) {
    return Promise.resolve([props.children, context]);
  }

  if (!isReactCompositeComponent(type)) {
    return Promise.resolve([type(props, context), context]);
  }

  const CompositeComponent = type;
  const instance = new CompositeComponent(props, context);
  instance.props = props;
  instance.context = context;
  return prepareComponentInstance(instance, context).then(prepareConfig => {
    // Stop traversing if the component is defer or boundary
    if (prepareConfig.defer || prepareConfig.boundary) {
      return Promise.resolve([null, context]);
    }

    return renderCompositeElementInstance(instance);
  });
} // TODO(#4) We can optimize this algorithm I think


function _prepare(element, context) {
  return prepareElement(element, context).then(([children, childContext]) => {
    return Promise.all(React__default.Children.toArray(children).map(child => _prepare(child, childContext)));
  });
}

function prepare(element, context = {}) {
  context.__IS_PREPARE__ = true;
  return _prepare(element, context).then(() => {
    context.__IS_PREPARE__ = false;
  });
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const CHUNKS_KEY = '__CHUNK_IDS';
const contextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired
}; // TODO(#7): Figure out what we are going to do with chunks/preloading

{
  contextTypes.preloadChunks = PropTypes.array.isRequired;
}

function withAsyncComponent({
  defer,
  load,
  LoadingComponent,
  ErrorComponent
}) {
  let AsyncComponent = null;
  let error = null;
  let chunkIds = [];

  function WithAsyncComponent(props) {
    if (error) {
      return React__default.createElement(ErrorComponent, {
        error: error
      });
    }

    if (!AsyncComponent) {
      return React__default.createElement(LoadingComponent, null);
    }

    return React__default.createElement(AsyncComponent, props);
  }

  return prepared((props, context) => {
    if (AsyncComponent) {
      {
        chunkIds.forEach(chunkId => {
          context.preloadChunks.push(chunkId);
        });
      }

      return Promise.resolve(AsyncComponent);
    }

    let componentPromise;

    try {
      componentPromise = load();
    } catch (e) {
      componentPromise = Promise.reject(e);
    }

    chunkIds = componentPromise[CHUNKS_KEY] || [];

    {
      chunkIds.forEach(chunkId => {
        context.preloadChunks.push(chunkId);
      });
    }

    const loadPromises = [componentPromise, ...context.splitComponentLoaders.map(loader => loader(chunkIds))];
    return Promise.all(loadPromises).then(([asyncComponent]) => {
      // TODO(#8) .default is toolchain specific, breaks w/ CommonJS exports
      AsyncComponent = asyncComponent.default;
    }).catch(err => {
      error = err;
       // log error
    });
  }, {
    defer,
    contextTypes,
    forceUpdate: true
  })(WithAsyncComponent);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// to visit the minimum number of nodes

var exclude = prepared(Promise.resolve(), {
  componentDidMount: false,
  componentWillReceiveProps: false,
  componentDidUpdate: false,
  defer: true
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class PrepareProvider extends React__default.Component {
  constructor(props, context) {
    super(props, context);
    this.splitComponentLoaders = [];
    this.preloadChunks = props.preloadChunks;
  }

  getChildContext() {
    return {
      splitComponentLoaders: this.splitComponentLoaders,
      preloadChunks: this.preloadChunks
    };
  }

  render() {
    return React__default.Children.only(this.props.children);
  }

}

PrepareProvider.childContextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired,
  preloadChunks: PropTypes.array.isRequired
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const middleware = function (ctx, next) {
  if (true && !ctx.element) {
    return next();
  }

  ctx.element = React__default.createElement(PrepareProvider, {
    preloadChunks: ctx.preloadChunks
  }, ctx.element);
  return next();
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const prepareTyped = prepare;
const preparedTyped = prepared;
const splitTyped = withAsyncComponent;
const excludeTyped = exclude; // TODO(#3): Can we get ride of some of these exports?

export { dispatched, prepareTyped as prepare, preparedTyped as prepared, splitTyped as split, excludeTyped as exclude, middleware };
//# sourceMappingURL=index.es.js.map
