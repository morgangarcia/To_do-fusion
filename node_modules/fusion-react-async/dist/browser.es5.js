'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var PropTypes = _interopDefault(require('prop-types'));
var reactIs = require('react-is');

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var REACT_PREPARE = '@__REACT_PREPARE__@';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var prepared = function prepared(_prepare, opts) {
  if (opts === void 0) {
    opts = {};
  }

  return function (OriginalComponent) {
    opts = Object.assign({
      boundary: false,
      defer: false,
      componentDidMount: true,
      componentWillReceiveProps: false,
      componentDidUpdate: false,
      contextTypes: {},
      forceUpdate: false
    }, opts);
    var prep = {
      prepare: function prepare() {
        return Promise.resolve(_prepare.apply(void 0, arguments));
      },
      defer: opts.defer
    };

    var PreparedComponent =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(PreparedComponent, _Component);

      function PreparedComponent(props, context) {
        var _this;

        _this = _Component.call(this, props, context) || this;
        _this[REACT_PREPARE] = prep;
        return _this;
      }

      var _proto = PreparedComponent.prototype;

      _proto.componentDidMount = function componentDidMount() {
        var _this2 = this;

        if (opts.componentDidMount) {
          Promise.resolve(_prepare(this.props, this.context)).then(function () {
            if (opts.forceUpdate) {
              _this2.forceUpdate(); // TODO(#10) document

            }
          });
        }
      };

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
        if (opts.componentWillReceiveProps) {
          _prepare(nextProps, nextContext);
        }
      };

      _proto.componentDidUpdate = function componentDidUpdate() {
        if (opts.componentDidUpdate) {
          _prepare(this.props, this.context);
        }
      };

      _proto.render = function render() {
        return React__default.createElement(OriginalComponent, this.props);
      };

      return PreparedComponent;
    }(React.Component);

    var displayName = OriginalComponent.displayName || OriginalComponent.name || '';
    PreparedComponent.contextTypes = opts.contextTypes;
    PreparedComponent.displayName = "PreparedComponent(" + displayName + ")";
    return PreparedComponent;
  };
};

function isPrepared(CustomComponent) {
  return CustomComponent[REACT_PREPARE] && typeof CustomComponent[REACT_PREPARE].prepare === 'function';
}

function getPrepare(CustomComponent) {
  return CustomComponent[REACT_PREPARE] || {};
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var storeShape = PropTypes.shape({
  dispatch: PropTypes.func.isRequired
});

var dispatched = function dispatched(prepareUsingDispatch, opts) {
  if (opts === void 0) {
    opts = {};
  }

  return function (OriginalComponent) {
    var prepare = function prepare(props, context) {
      return prepareUsingDispatch(props, context.store.dispatch);
    };

    var contextTypes = Object.assign({}, opts && opts.contextTypes ? opts.contextTypes : {}, {
      store: storeShape
    });
    var preparedOpts = Object.assign({}, opts, {
      contextTypes: contextTypes
    });
    return prepared(prepare, preparedOpts)(OriginalComponent);
  };
};

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function isReactCompositeComponent(type) {
  if (typeof type !== 'function') {
    return false;
  }

  if (_typeof(type.prototype) !== 'object') {
    return false;
  }

  if (typeof type.prototype.render !== 'function') {
    return false;
  }

  return true;
}

function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function renderCompositeElementInstance(instance) {
  var childContext = Object.assign({}, instance.context, instance.getChildContext ? instance.getChildContext() : {});

  if (instance.componentWillMount) {
    instance.componentWillMount();
  }

  var children = instance.render();
  return [children, childContext];
}

function prepareComponentInstance(instance) {
  if (!isPrepared(instance)) {
    return Promise.resolve({});
  }

  var prepareConfig = getPrepare(instance); // If the component is deferred, skip the prepare step

  if (prepareConfig.defer) {
    return Promise.resolve(prepareConfig);
  }

  return prepareConfig.prepare(instance.props, instance.context).then(function () {
    return prepareConfig;
  });
}

function prepareElement(element, context) {
  if (element === null || _typeof$1(element) !== 'object') {
    return Promise.resolve([null, context]);
  }

  var type = element.type,
      props = element.props;

  if (typeof type === 'string' || reactIs.isFragment(element) || reactIs.isContextConsumer(element) || reactIs.isContextProvider(element)) {
    return Promise.resolve([props.children, context]);
  }

  if (!isReactCompositeComponent(type)) {
    return Promise.resolve([type(props, context), context]);
  }

  var CompositeComponent = type;
  var instance = new CompositeComponent(props, context);
  instance.props = props;
  instance.context = context;
  return prepareComponentInstance(instance, context).then(function (prepareConfig) {
    // Stop traversing if the component is defer or boundary
    if (prepareConfig.defer || prepareConfig.boundary) {
      return Promise.resolve([null, context]);
    }

    return renderCompositeElementInstance(instance);
  });
} // TODO(#4) We can optimize this algorithm I think


function _prepare(element, context) {
  return prepareElement(element, context).then(function (_ref) {
    var children = _ref[0],
        childContext = _ref[1];
    return Promise.all(React__default.Children.toArray(children).map(function (child) {
      return _prepare(child, childContext);
    }));
  });
}

function prepare(element, context) {
  if (context === void 0) {
    context = {};
  }

  context.__IS_PREPARE__ = true;
  return _prepare(element, context).then(function () {
    context.__IS_PREPARE__ = false;
  });
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var CHUNKS_KEY = '__CHUNK_IDS';
var contextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired
}; // TODO(#7): Figure out what we are going to do with chunks/preloading

function withAsyncComponent(_ref) {
  var defer = _ref.defer,
      load = _ref.load,
      LoadingComponent = _ref.LoadingComponent,
      ErrorComponent = _ref.ErrorComponent;
  var AsyncComponent = null;
  var error = null;
  var chunkIds = [];

  function WithAsyncComponent(props) {
    if (error) {
      return React__default.createElement(ErrorComponent, {
        error: error
      });
    }

    if (!AsyncComponent) {
      return React__default.createElement(LoadingComponent, null);
    }

    return React__default.createElement(AsyncComponent, props);
  }

  return prepared(function (props, context) {
    if (AsyncComponent) {
      return Promise.resolve(AsyncComponent);
    }

    var componentPromise;

    try {
      componentPromise = load();
    } catch (e) {
      componentPromise = Promise.reject(e);
    }

    chunkIds = componentPromise[CHUNKS_KEY] || [];

    var loadPromises = [componentPromise].concat(context.splitComponentLoaders.map(function (loader) {
      return loader(chunkIds);
    }));
    return Promise.all(loadPromises).then(function (_ref2) {
      var asyncComponent = _ref2[0];
      // TODO(#8) .default is toolchain specific, breaks w/ CommonJS exports
      AsyncComponent = asyncComponent.default;
    }).catch(function (err) {
      error = err;
      setTimeout(function () {
        throw err;
      }); // log error
    });
  }, {
    defer: defer,
    contextTypes: contextTypes,
    forceUpdate: true
  })(WithAsyncComponent);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// to visit the minimum number of nodes

var exclude = prepared(Promise.resolve(), {
  componentDidMount: false,
  componentWillReceiveProps: false,
  componentDidUpdate: false,
  defer: true
});

function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var PrepareProvider =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose$1(PrepareProvider, _React$Component);

  function PrepareProvider(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    _this.splitComponentLoaders = [];
    _this.preloadChunks = props.preloadChunks;
    return _this;
  }

  var _proto = PrepareProvider.prototype;

  _proto.getChildContext = function getChildContext() {
    return {
      splitComponentLoaders: this.splitComponentLoaders,
      preloadChunks: this.preloadChunks
    };
  };

  _proto.render = function render() {
    return React__default.Children.only(this.props.children);
  };

  return PrepareProvider;
}(React__default.Component);

PrepareProvider.childContextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired,
  preloadChunks: PropTypes.array.isRequired
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var middleware = function middleware(ctx, next) {
  ctx.element = React__default.createElement(PrepareProvider, {
    preloadChunks: ctx.preloadChunks
  }, ctx.element);
  return next();
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var prepareTyped = prepare;
var preparedTyped = prepared;
var splitTyped = withAsyncComponent;
var excludeTyped = exclude; // TODO(#3): Can we get ride of some of these exports?

exports.dispatched = dispatched;
exports.prepare = prepareTyped;
exports.prepared = preparedTyped;
exports.split = splitTyped;
exports.exclude = excludeTyped;
exports.middleware = middleware;
//# sourceMappingURL=browser.es5.js.map
